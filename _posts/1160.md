title: 'MySQL 学习笔记 优化篇'
tags:
  - MySQL
  - 优化
  - 数据库
id: 1160
categories:
  - Learn
  - Coding
  - MySQL
date: 2014-04-27 16:48:01
---


使用索引：


*   **尽量为用来搜索/分类/分组的数据列编制索引，不要为作为输出显示的数据列编制索引。（WHERE / 联结字句 / ORDER BY / GROUP BY）；**
*   数据列的维度越高，它包含的独一无二的值就越多，重复的值就越少，索引的使用效果也就越好；
*   对短小的值进行索引；
*   要为字符串数据列编索引，应当尽可能给出前缀长度；
*   **复合****索引中最左边的数据列能够用于匹配数据行；**
*   适可而止
*   让索引类型与你打算进行的比较操作的类型保持匹配；
*   利用慢查询日志找出性能低劣的查询；

<!--more-->

MySQL的查询优化程序：


*   对数据表进行分析：ANALYSE TABLE；
*   使用EXPLAIN语句来验证优化器操作；
*   向优化器提供提示或在必要时屏蔽之：FORCE INDEX / USE INDEX / IGNORE INDEX；
*   **尽量使用数据类型相同的数据列进行比较；**
*   **使带索引的数据列在比较表达式中单独出现；**
*   不要在LIKE模式的开始位置使用通配符；
*   优化器对联结的优化效果要比对子查询的优化效果更好一些；
*   实验各种查询的变化格式，而且要多次运行它们；
*   避免过多使用MySQL的自动类型转换功能;
为提高查询效率而挑选数据类型：

*   尽量使用数值操作，少使用字符串操作；
*   尽量选用最适用与存储引擎的格式：MyISAM尽量适用固定长度的数据列（加快查询，减少碎片，加快修复）；
*   尽量把数据列声明为NOT NULL；
*   考虑使用ENUM数据列；
*   PROCEDURE ANALYSE（）：对数据表里的各数据列的优化建议；select * from lxy_category procedure analyse();
*   对容易产生碎片的数据表进行整理：定期使用OPTIMIZE TABLE清理MyISAM数据表里的碎片，其它引擎先用mysqldump转储数据表，再利用转储文件删除并重建一个；
*   把数据压缩到BLOB或TEXT数据列里；
*   使用人造索引：计算某数据列的散列值并保存到一个数据列里，适用于精确匹配型查询；
*   尽量避免对很大的BLOB或TEXT值进行检索；
*   把BLOB或TEXT数据列剥离到单独一个数据表里；
有效加载数据：

*   批量加载的效率比单数据行加载的效率高；
*   加载有索引的数据表比加载无索引的数据表快一些；
*   较短的SQL语句与数据加载i较长的语句块；
系统管理员所完成的优化：

*   增加数据表缓存：table_open_cache系统变量；
*   使用MySQL键缓存：MySQL支持建立多个键缓存，我们可以微某个数据表分配一个键缓存并把该数据表的索引提前加载到该缓存；
*   禁用那些你不需要的存储引擎；
*   使用查询缓存：have_query_cache系统变量：SELECT SQL_CACHE/SQL_NO_CACHE；
硬件优化：



*   ​更多的内存；
*   如果有足够的RAM可以让数据交换都发生在一个内存文件系统里，可以重新配置你的系统来删除所有的磁盘数据交换设备；
*   更快的磁盘（SSD哈哈）；
*   在物理设备之间分散磁盘读写活动，提高并行度；
*   使用多处理器硬件（多线程）。

